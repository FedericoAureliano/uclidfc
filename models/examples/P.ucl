// UCLID TEST
// Solver=z3
// Result=Some(false)

// Declare machine reference types
type AbstractServerMachine_ref_t = enum {server_a};
type ClientMachine_ref_t = enum {client_a};
const default_server: AbstractServerMachine_ref_t;
const default_client: ClientMachine_ref_t;

// Declare event types
type eRequest_t = record {source: ClientMachine_ref_t, target: AbstractServerMachine_ref_t, id : integer};
type eResponse_t = record {source: AbstractServerMachine_ref_t, target: ClientMachine_ref_t, id : integer, success: boolean};

// Declare event queue types
type eRequest_queue = record {start: integer, end: integer, data: [integer]eRequest_t};
type eResponse_queue = record {start: integer, end: integer, data: [integer]eResponse_t};

// Declare event queue helpers
define pop_request(q: eRequest_queue) : eRequest_queue = eRequest_queue(q.start + 1, q.end, q.data);
define peak_request(q: eRequest_queue) : eRequest_t = q.data[q.start];
define push_request(q: eRequest_queue, r : eRequest_t) : eRequest_queue = eRequest_queue(q.start, q.end + 1, q.data[q.end -> r]);
define init_requests() : eRequest_queue = eRequest_queue(0, 0, const(eRequest_t(default_client, default_server, 0), [integer]eRequest_t));
define is_empty_requests(q: eRequest_queue) : boolean = q.end <= q.start;
define requests_size(q: eRequest_queue) : integer = q.end - q.start; // only with integers

define pop_response(q: eResponse_queue) : eResponse_queue = eResponse_queue(q.start + 1, q.end, q.data);
define peak_response(q: eResponse_queue) : eResponse_t = q.data[q.start];
define push_response(q: eResponse_queue, r: eResponse_t) : eResponse_queue = eResponse_queue(q.start, q.end + 1, q.data[q.end -> r]);
define init_responses() : eResponse_queue = eResponse_queue(0, 0, const(eResponse_t(default_server, default_client, 0, false), [integer]eResponse_t));
define is_empty_responses(q: eResponse_queue) : boolean = q.end <= q.start;
define responses_size(q: eResponse_queue) : integer = q.end - q.start; // only with integers

// declare machines
module AbstractServerMachine {
    
    sharedvar eRequest_in : eRequest_queue;
    sharedvar eResponse_out : eResponse_queue;

    var success : boolean;
    
    init
    {
        eRequest_in = init_requests();
        eResponse_out = init_responses();
    }// End of init block

    next
    {
        if (!is_empty_requests(eRequest_in)) {
            havoc success;
            // send a response
            let top = peak_request(eRequest_in);
            eResponse_out = push_response(eResponse_out, eResponse_t(top.target, top.source, top.id, success));
            // pop request
            eRequest_in = pop_request(eRequest_in);
        }
    }// End of next block

} // End of AbstractServerMachine module

module ClientMachine {
    sharedvar eResponse_in : eResponse_queue;
    sharedvar eRequest_out : eRequest_queue;
    
    var entry : boolean;
    
    // Declare local variables
    var server : AbstractServerMachine_ref_t;
    var next_id : integer;
    var last_id : integer;

    var this : ClientMachine_ref_t;

    // ghosts
    var ghost_last_id : integer;

    init
    {
        next_id = 1;
        last_id = 0;
        entry = true;

        eResponse_in = init_responses();
        eRequest_out = init_requests();

        ghost_last_id = 0;
    }// End of init block

    next
    {
        ghost_last_id = last_id;
        if (entry) {
            // send request
            eRequest_out = push_request(eRequest_out, eRequest_t(this, server, next_id));
            next_id = next_id + 1;
            entry = false;
        } else {
            if (!is_empty_responses(eResponse_in)) {
                last_id = peak_response(eResponse_in).id;
                eResponse_in = pop_response(eResponse_in);
                entry = true;
            }
        }
    }// End of next block

} // End of ClientMachine module

type cases = enum {client_to_server, server_to_client};

module main {
    var sinstances : [AbstractServerMachine_ref_t]AbstractServerMachine;
    var cinstances : [ClientMachine_ref_t]ClientMachine;
    var schoice: AbstractServerMachine_ref_t;
    var cchoice: ClientMachine_ref_t;
    var sstep: boolean;
    var cstep: boolean;

    var mediate: boolean;

    var AbstractServerMachine_tmp : AbstractServerMachine_ref_t;
    var ClientMachine_tmp : ClientMachine_ref_t;

    var case_switch : cases;

    next {
        havoc mediate;
        if (mediate) {
            havoc case_switch;
            case 
            (case_switch == server_to_client) : {
                havoc AbstractServerMachine_tmp;
                let server_responses = sinstances[AbstractServerMachine_tmp].eResponse_out;
                if (!is_empty_responses(server_responses)) {
                    let top = peak_response(server_responses);
                    let client_responses = cinstances[top.target].eResponse_in;
                    // send to client
                    cinstances[top.target].eResponse_in = push_response(client_responses, top);
                    // remove from server
                    sinstances[AbstractServerMachine_tmp].eResponse_out = pop_response(server_responses);
                }
            }
            (case_switch == client_to_server) : {
                havoc ClientMachine_tmp;
                let client_requests = cinstances[ClientMachine_tmp].eRequest_out;
                if (!is_empty_requests(client_requests)) {
                    let top = peak_request(client_requests);
                    let server_requests = sinstances[top.target].eRequest_in;
                    // send to server
                    sinstances[top.target].eRequest_in = push_request(server_requests, top);
                    // remove from client
                    cinstances[ClientMachine_tmp].eRequest_out = pop_request(client_requests);
                }
            }
            esac
        } else {
            if (cstep) {
                havoc cstep;
                havoc cchoice;
                next(cinstances[cchoice]);
            }
            if (sstep) {
                havoc sstep;
                havoc schoice;
                next(sinstances[schoice]);
            }
        }
    }

    invariant assertion: !is_empty_responses(cinstances[client_a].eResponse_in) ==> 
        peak_response(cinstances[client_a].eResponse_in).id > cinstances[client_a].ghost_last_id;

    invariant max_one_event_in_whole_system: 
        responses_size(sinstances[server_a].eResponse_out) + 
        responses_size(cinstances[client_a].eResponse_in) + 
        requests_size(sinstances[server_a].eRequest_in) + 
        requests_size(cinstances[client_a].eRequest_out) <= 1;

    invariant entry_means_everything_empty: cinstances[client_a].entry ==>
        responses_size(sinstances[server_a].eResponse_out) + 
        responses_size(cinstances[client_a].eResponse_in) + 
        requests_size(sinstances[server_a].eRequest_in) + 
        requests_size(cinstances[client_a].eRequest_out) == 0;

    invariant sizes_never_negative: 
        responses_size(sinstances[server_a].eResponse_out) >= 0 &&
        responses_size(cinstances[client_a].eResponse_in) >= 0 &&
        requests_size(sinstances[server_a].eRequest_in) >= 0 &&
        requests_size(cinstances[client_a].eRequest_out) >= 0;

    invariant sizes_never_gt_1: 
        responses_size(sinstances[server_a].eResponse_out) <= 1 &&
        responses_size(cinstances[client_a].eResponse_in) <= 1 &&
        requests_size(sinstances[server_a].eRequest_in) <= 1 &&
        requests_size(cinstances[client_a].eRequest_out) <= 1;

    invariant every_event_id_gt_last_id: 
        (!is_empty_requests(cinstances[client_a].eRequest_out) ==> 
            peak_request(cinstances[client_a].eRequest_out).id == cinstances[client_a].next_id - 1) &&
        (!is_empty_requests(sinstances[server_a].eRequest_in) ==> 
            peak_request(sinstances[server_a].eRequest_in).id == cinstances[client_a].next_id - 1) &&
        (!is_empty_responses(sinstances[server_a].eResponse_out) ==> 
            peak_response(sinstances[server_a].eResponse_out).id == cinstances[client_a].next_id - 1) &&
        (!is_empty_responses(cinstances[client_a].eResponse_in) ==> 
            peak_response(cinstances[client_a].eResponse_in).id == cinstances[client_a].next_id - 1);

    invariant next_gt_last: 
        cinstances[client_a].next_id - cinstances[client_a].last_id > 1 || 
        (cinstances[client_a].entry && cinstances[client_a].next_id - cinstances[client_a].last_id == 1);

    invariant ghost_trails_real: cinstances[client_a].last_id >= cinstances[client_a].ghost_last_id;

    invariant all_ids_gte_zero: cinstances[client_a].last_id >= 0 && cinstances[client_a].next_id >= 0 && cinstances[client_a].ghost_last_id >= 0;

    control {
        induction;
        set_solver_option("timeout", "5000");
        check;
        print_cex(
            responses_size(cinstances[client_a].eResponse_in),
            peak_response(cinstances[client_a].eResponse_in).id,
            cinstances[client_a].next_id,
            cinstances[client_a].last_id,
            cinstances[client_a].ghost_last_id
        );
    }
}