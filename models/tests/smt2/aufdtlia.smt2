; UCLID TEST
; Solver=z3
; Result=Some(false)
; Option=print-features

(set-info :smt-lib-version 2.6)
(set-logic AUFDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: DVF, converted to v2.6 by CVC4
Application: Verification of security protocols and design architectures
Target solver: CVC4, Z3, Yices
Publications: "Finite Model Finding in SMT" by Andrew Reynolds, Cesare Tinelli, Amit Goel, and Sava Krstic, CAV 2013.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)

(declare-datatypes ((UNIT 0)) (((Unit))
))
(declare-datatypes ((BOOL 0)) (((Truth) (Falsity))
))
(declare-sort node$type 0)
(declare-sort value$type 0)
(declare-sort Nodes$t$type 0)
(declare-fun Nodes$empty () Nodes$t$type)
(declare-fun Nodes$mem (node$type Nodes$t$type) BOOL)
(declare-fun Nodes$add (node$type Nodes$t$type) Nodes$t$type)
(declare-fun Nodes$remove (node$type Nodes$t$type) Nodes$t$type)
(declare-fun Nodes$cardinality (Nodes$t$type) Int)
(declare-fun Nodes$union (Nodes$t$type Nodes$t$type) Nodes$t$type)
(declare-fun Nodes$disjoint (Nodes$t$type Nodes$t$type) BOOL)
(assert (forall ((a Nodes$t$type)) (= (Nodes$disjoint a Nodes$empty) Truth) ))
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (= (Nodes$disjoint a b) (Nodes$disjoint b a)) ))
(assert (forall ((e node$type)) (not (= (Nodes$mem e Nodes$empty) Truth)) ))
(assert (forall ((x node$type) (y node$type) (s Nodes$t$type)) (= (Nodes$mem x (Nodes$add y s)) (ite (or (= x y) (= (Nodes$mem x s) Truth)) Truth Falsity)) ))
(assert (forall ((x node$type) (y node$type) (s Nodes$t$type)) (= (Nodes$mem x (Nodes$remove y s)) (ite (and (not (= x y)) (= (Nodes$mem x s) Truth)) Truth Falsity)) ))
(assert (forall ((x node$type) (a Nodes$t$type)) (=> (= (Nodes$mem x a) Truth) (forall ((b Nodes$t$type)) (= (Nodes$mem x (Nodes$union a b)) Truth) )) ))
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (= (Nodes$union a b) (Nodes$union b a)) ))
(assert (forall ((x node$type) (a Nodes$t$type) (b Nodes$t$type)) (=> (= (Nodes$mem x (Nodes$union a b)) Truth) (or (= (Nodes$mem x a) Truth) (= (Nodes$mem x b) Truth))) ))
(assert (forall ((a Nodes$t$type)) (= (Nodes$union a a) a) ))
(assert (forall ((a Nodes$t$type)) (= (Nodes$union a Nodes$empty) a) ))
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (=> (= (Nodes$union a b) Nodes$empty) (= a Nodes$empty)) ))
(assert (= (Nodes$cardinality Nodes$empty) 0))
(assert (forall ((s Nodes$t$type)) (=> (= (Nodes$cardinality s) 0) (= s Nodes$empty)) ))
(assert (forall ((s Nodes$t$type)) (>= (Nodes$cardinality s) 0) ))
(assert (forall ((x node$type) (s Nodes$t$type)) (= (Nodes$cardinality (Nodes$add x s)) (ite (= (Nodes$mem x s) Truth) (Nodes$cardinality s) (+ (Nodes$cardinality s) 1))) ))
(assert (forall ((x node$type) (s Nodes$t$type)) (= (Nodes$cardinality (Nodes$remove x s)) (ite (= (Nodes$mem x s) Truth) (- (Nodes$cardinality s) 1) (Nodes$cardinality s))) ))
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (=> (= (Nodes$disjoint a b) Truth) (= (Nodes$cardinality (Nodes$union a b)) (+ (Nodes$cardinality a) (Nodes$cardinality b)))) ))
(declare-fun Nodes$eq (Nodes$t$type Nodes$t$type) BOOL)
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (= (Nodes$eq a b) (ite (= a b) Truth Falsity)) ))
(assert (forall ((a Nodes$t$type) (b Nodes$t$type)) (=> (forall ((x node$type)) (= (Nodes$mem x a) (Nodes$mem x b)) ) (= (Nodes$eq a b) Truth)) ))
(declare-sort Values$t$type 0)
(declare-fun Values$empty () Values$t$type)
(declare-fun Values$mem (value$type Values$t$type) BOOL)
(declare-fun Values$add (value$type Values$t$type) Values$t$type)
(declare-fun Values$remove (value$type Values$t$type) Values$t$type)
(declare-fun Values$cardinality (Values$t$type) Int)
(declare-fun Values$union (Values$t$type Values$t$type) Values$t$type)
(declare-fun Values$disjoint (Values$t$type Values$t$type) BOOL)
(assert (forall ((a Values$t$type)) (= (Values$disjoint a Values$empty) Truth) ))
(assert (forall ((a Values$t$type) (b Values$t$type)) (= (Values$disjoint a b) (Values$disjoint b a)) ))
(assert (forall ((e value$type)) (not (= (Values$mem e Values$empty) Truth)) ))
(assert (forall ((x value$type) (y value$type) (s Values$t$type)) (= (Values$mem x (Values$add y s)) (ite (or (= x y) (= (Values$mem x s) Truth)) Truth Falsity)) ))
(assert (forall ((x value$type) (y value$type) (s Values$t$type)) (= (Values$mem x (Values$remove y s)) (ite (and (not (= x y)) (= (Values$mem x s) Truth)) Truth Falsity)) ))
(assert (forall ((x value$type) (a Values$t$type)) (=> (= (Values$mem x a) Truth) (forall ((b Values$t$type)) (= (Values$mem x (Values$union a b)) Truth) )) ))
(assert (forall ((a Values$t$type) (b Values$t$type)) (= (Values$union a b) (Values$union b a)) ))
(assert (forall ((x value$type) (a Values$t$type) (b Values$t$type)) (=> (= (Values$mem x (Values$union a b)) Truth) (or (= (Values$mem x a) Truth) (= (Values$mem x b) Truth))) ))
(assert (forall ((a Values$t$type)) (= (Values$union a a) a) ))
(assert (forall ((a Values$t$type)) (= (Values$union a Values$empty) a) ))
(assert (forall ((a Values$t$type) (b Values$t$type)) (=> (= (Values$union a b) Values$empty) (= a Values$empty)) ))
(assert (= (Values$cardinality Values$empty) 0))
(assert (forall ((s Values$t$type)) (=> (= (Values$cardinality s) 0) (= s Values$empty)) ))
(assert (forall ((s Values$t$type)) (>= (Values$cardinality s) 0) ))
(assert (forall ((x value$type) (s Values$t$type)) (= (Values$cardinality (Values$add x s)) (ite (= (Values$mem x s) Truth) (Values$cardinality s) (+ (Values$cardinality s) 1))) ))
(assert (forall ((x value$type) (s Values$t$type)) (= (Values$cardinality (Values$remove x s)) (ite (= (Values$mem x s) Truth) (- (Values$cardinality s) 1) (Values$cardinality s))) ))
(assert (forall ((a Values$t$type) (b Values$t$type)) (=> (= (Values$disjoint a b) Truth) (= (Values$cardinality (Values$union a b)) (+ (Values$cardinality a) (Values$cardinality b)))) ))
(declare-fun Values$eq (Values$t$type Values$t$type) BOOL)
(assert (forall ((a Values$t$type) (b Values$t$type)) (= (Values$eq a b) (ite (= a b) Truth Falsity)) ))
(assert (forall ((a Values$t$type) (b Values$t$type)) (=> (forall ((x value$type)) (= (Values$mem x a) (Values$mem x b)) ) (= (Values$eq a b) Truth)) ))
(declare-fun mk_array_1 () (Array node$type BOOL))
(assert (forall ((mk_array_1_index node$type)) (= (select mk_array_1 mk_array_1_index) Falsity) ))
(define-fun empty_node_set () (Array node$type BOOL) mk_array_1)
(declare-fun mk_array_2 () (Array node$type BOOL))
(assert (forall ((mk_array_2_index node$type)) (= (select mk_array_2 mk_array_2_index) Falsity) ))
(declare-fun mk_array_3 () (Array node$type (Array node$type BOOL)))
(assert (forall ((mk_array_3_index node$type)) (= (select mk_array_3 mk_array_3_index) mk_array_2) ))
(define-fun empty_node_pair_set () (Array node$type (Array node$type BOOL)) mk_array_3)
(declare-fun mk_array_4 () (Array node$type BOOL))
(assert (forall ((mk_array_4_index node$type)) (= (select mk_array_4 mk_array_4_index) Truth) ))
(declare-fun mk_array_5 () (Array node$type (Array node$type BOOL)))
(assert (forall ((mk_array_5_index node$type)) (= (select mk_array_5 mk_array_5_index) mk_array_4) ))
(define-fun full_node_pair_set () (Array node$type (Array node$type BOOL)) mk_array_5)
(declare-fun input () (Array node$type value$type))
(declare-fun t () Int)
(assert (> t 0))
(define-fun null_message () Values$t$type Values$empty)
(declare-fun mk_array_6 () (Array node$type Values$t$type))
(assert (forall ((mk_array_6_index node$type)) (= (select mk_array_6 mk_array_6_index) null_message) ))
(define-fun null_message_set () (Array node$type Values$t$type) mk_array_6)
(define-fun null_state () Values$t$type Values$empty)
(declare-fun mk_array_7 () (Array node$type Values$t$type))
(assert (forall ((mk_array_7_index node$type)) (= (select mk_array_7 mk_array_7_index) null_state) ))
(define-fun null_state_set () (Array node$type Values$t$type) mk_array_7)
(declare-fun choose (Values$t$type) value$type)
(assert (forall ((vals Values$t$type)) (or (= vals Values$empty) (= (Values$mem (choose vals) vals) Truth)) ))
(define-fun is_faulty ((p node$type) (deliver (Array node$type (Array node$type BOOL)))) BOOL (ite (exists ((q node$type)) (not (= (select (select deliver p) q) Truth)) ) Truth Falsity))
(define-fun is_silent ((p node$type) (deliver (Array node$type (Array node$type BOOL)))) BOOL (ite (forall ((q node$type)) (not (= (select (select deliver p) q) Truth)) ) Truth Falsity))
(declare-datatypes ((phase_state$type 0)) (((init_phase) (send_phase) (recv_phase) (comp_phase))
))
(declare-datatypes ((clean_state$type 0)) (((before) (active) (after))
))
(declare-fun init_done () (Array node$type BOOL))
(declare-fun crashed () Nodes$t$type)
(declare-fun comp_done () (Array node$type BOOL))
(declare-fun chosen () (Array node$type BOOL))
(declare-fun recv_done () (Array node$type (Array node$type BOOL)))
(declare-fun phase () phase_state$type)
(declare-fun clean () clean_state$type)
(declare-fun global_state () (Array node$type Values$t$type))
(declare-fun messages () (Array node$type (Array node$type Values$t$type)))
(declare-fun deliver_message () (Array node$type (Array node$type BOOL)))
(declare-fun crashing () Nodes$t$type)
(declare-fun round () Int)
(declare-fun send_done () (Array node$type (Array node$type BOOL)))
(declare-fun mk_array_8 () (Array node$type BOOL))
(assert (forall ((mk_array_8_index node$type)) (= (select mk_array_8 mk_array_8_index) Falsity) ))
(declare-fun mk_array_9 () (Array node$type (Array node$type Values$t$type)))
(assert (forall ((mk_array_9_index node$type)) (= (select mk_array_9 mk_array_9_index) null_message_set) ))
(assert (not (=> (and (and (and (and (and (and (and (and (and (and (and (and (= clean before) (= global_state null_state_set)) (= messages mk_array_9)) (= deliver_message full_node_pair_set)) (= comp_done empty_node_set)) (= recv_done empty_node_pair_set)) (= send_done empty_node_pair_set)) (= init_done empty_node_set)) (= phase init_phase)) (= crashing Nodes$empty)) (= crashed Nodes$empty)) (= round 0)) (= chosen mk_array_8)) (=> (= phase init_phase) (forall ((n node$type) (m node$type)) (not (= (select (select send_done n) m) Truth)) )))))
(check-sat)
(exit)

