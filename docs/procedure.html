<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Uclid First-Class</title>
  <link rel="stylesheet" href="https://latex.now.sh/style.css">
  <link rel="stylesheet" href="css/main.css">
</head>

<body id="top">
  <header>
    <h1>Uclid First-Class5</h1>
    <p class="author">
      Federico Mora
    </p>
  </header>

  <main>
    <article>
      <h2 id="procedure">2. Procedure Language</h2>
      <p>

        The procedure language handles all sequential code. To deal with constructs
        like loops we define the semantics of the procedure language using
        Floyd-Hoare logic.
      </p>

      <p>

        Procedure declarations are the only interface between the procedure
        language and the core language. There are three special cases for a
        procedure declaration, denoted by the annotations "inline," "noinline,"
        and "infer." In all three cases, a procedure $p$ is associated with
        a record type $p_t$ and a function $f_p$ that returns an element of
        $p_t$. The parameters of $f_p$ are the same as the parameters of $p$
        plus the module type, and the elements of $p_t$ are the
        <code>return</code>s and <code>modifies</code>s of $p$. When inlining,
        the function $f_p$ is actually a macro, this is only possible when the
        procedure has no loops or cyclic procedure calls. When not inlining,
        the function $f_p$ is an uninterpreted function with associated
        assertions: "noinline" will use the <code>require</code>s and
        <code>ensure</code>s; "infer" will use the <code>require</code>s and a
        strongest-post-condition.

      </p>

      <p>

        To use procedure calls in the core language, all we need to do is call the
        function $f_p$ and select the appropriate outputs when constructing the new
        module instance. For example, the Uclid5 module

      </p>

      <pre><code>module main {
var a, b : integer;

procedure[inline] p(x : integer, y : integer)
  returns (z : integer)
{
  z = x + y;
}

init {
  a' = 0;
  b' = 1;
}

next {
  a' = b;
  call (b') = p(a, b);
}

invariant a_le_b: a &lt;= b;
}</code></pre>

      <p>

        is encoded as

      </p>

      <pre><code>(declare-datatypes ((main 0)) (((main!cntr (a Int) (b Int)))))
(declare-datatypes ((p_t 0)) (((p (z Int)))))
(define-fun f_p ((x Int) (y Int) (in main)) p_t (p (+ x y)))

(define-fun main!init ((in main)) main (main!cntr 0 1))
(define-fun main!next ((in main)) main (main!cntr (b in) (z (f_p (a in) (b in) in))))
(define-fun main!spec ((in main)) Bool (&lt;= (a in) (b in)))</code></pre>

      <p>

        and with "inline" replaced by "infer," the same module is encoded as

      </p>


      <pre><code>(declare-datatypes ((main 0)) (((main!cntr (a Int) (b Int)))))
(declare-datatypes ((p_t 0)) (((p (z Int)))))
(declare-fun f_p (Int Int main) p_t)
(assert (forall ((i Int) (j Int) (m main)) (=> true (= (z (f_p i j m)) (+ i j)))))

(define-fun main!init ((in main)) main (main!cntr 0 1))
(define-fun main!next ((in main)) main (main!cntr (b in) (z (f_p (a in) (b in) in))))
(define-fun main!spec ((in main)) Bool (&lt;= (a in) (b in)))</code></pre>

      <p>

        The responsibility of the procedure language is to provide the core language
        with the function body in the case of "inline" and the pre- and
        post-conditions otherwise.

      </p>

    </article>
  </main>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'],],
      },
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>

</html>