<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trilingual Uclid</title>
  <link rel="stylesheet" href="https://latex.now.sh/style.css">
  <link rel="stylesheet" href="css/main.css">
</head>

<body id="top">
  <header>
    <h1>Trilingual Uclid5</h1>
    <p class="author">
      Federico Mora
    </p>
  </header>

  <main>
    <article>

      <h2 id="proof">3. Proof Language</h2>
      <p>

        The proof language is the subset of Uclid5 that covers the control block. The
        control block of a module represents a sequential program over the symbols
        $t$, $i$, $n$, and $s$ of the module in question. For complete flexibility,
        we will define the proof language using operational semantics.

      </p>

      <p>

        For example, bounded model checking could be defined as a library function in the proof language like this

      </p>

      <pre><code>def bmc(k):
  current = init
  for i in range(0, k+1):
      solver.push()
      solver.add(!spec(current))
      result = solver.check()
      if result == SAT:
          return solver.model()
      solver.pop()
      current = next(current)
</code></pre>

      <p>

        and Uclid5 users would then use this library function to check their programs or build more interesting proof
        procedures, like synthesis procedures.

      </p>

      <p>

        <b>Synthesis Functions. </b>
        The core language interfaces with the proof language through synthesis
        function declarations. These are empty functions that must be filled in by
        the proof program. The requirement for how these empty functions must be
        filled in is given by a proof procedure, like bound model checking.

      </p>

      <p>

        In other words, synthesis function declarations act as placeholders in the core language that the proof language
        can fill-in as desired.

      </p>

      <h3>Other Oracles</h3>

      <p>

        The proof language is flexible enough to incorporate arbitrary oracles. For
        example, consider how we might implement specification mining. Specification
        mining is one technique for proof programs to fill in the bodies of synthesis
        functions. This technique relies on observations (data) that are imported into
        the proof program but may come from anywhere. To realize specification mining,
        we extend the proof language with an <code>import</code> keyword. The intuition
        is that <code>import</code> gives us access to an external database of
        observations.

      </p>

    </article>
  </main>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'],],
      },
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>

</html>