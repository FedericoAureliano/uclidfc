<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Uclid First-Class</title>
  <link rel="stylesheet" href="https://latex.now.sh/style.css">
  <link rel="stylesheet" href="css/main.css">
</head>

<body id="top">
  <header>
    <h1>First-Class Modules in Uclid5</h1>
    <p class="author">
      Federico Mora
    </p>
  </header>

  <main>
    <article>

      <h2 id="semantics">1. Core Language</h2>
      <p>

        The core language is the subset of Uclid5 that covers system descriptions and
        specifications. We define the semantics of this language in terms of the
        semantics of <span style="font-variant: small-caps;">smt-lib</span>, as defined
        in Chapter 5 of the <span style="font-variant: small-caps;">smt-lib</span>
        standard [<a
        href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">1</a>].
        We treat functions, loops, linear temporal logic, module interfaces, and inline
        specifications (e.g. <code>assert</code>), as extensions and address them
        later.

      </p>

      <p>

        Modules define the interpretation of corresponding symbols $t$, $i$,
        $n$, and $s$, where $t$ is an algebraic datatype representing the state
        space of the module; $i : t t$ is a function from $t$ to $t$
        representing the initial state of the module; $n : t t$ is a function
        from $t$ to $t$ representing the transition relation of the module; and
        $s : t \textbf{Bool}$ is a predicate on $t$ representing the
        specification on states of the module.

      </p>

      <p>

        For example, the Uclid5 module

      </p>

      <textarea id="demofull">module main {
  synthesis function h(x : integer, y : integer) : boolean;
  var a, b : integer;

  init {
    a = 0;
    b = 1;
  }
  next {
    a', b' = b, a + b;
  }

  invariant a_le_b: a &lt;= b && h(a, b);

  control {
    induction;
  }
}</textarea>

      <p>

        is semantically equivalent to the following
        <span style="font-variant: small-caps;">smt-lib</span>/<span style="font-variant: small-caps;">s</span>y<span
          style="font-variant: small-caps;">g</span>u<span style="font-variant: small-caps;">s</span>-<span
          style="font-variant: small-caps;">if</span></span>.<label for="sn-1" class="sidenote-toggle
          sidenote-number"></label> <input type="checkbox" id="sn-1" class="sidenote-toggle" /> <span
          class="sidenote">Try out the interactive translation and check the generated query with
          CVC4's online interface [<a href="https://cvc4.github.io/app/#temp_be5b8691-1e6e-405a-8053-f6c47abd9607"
            target="_blank">2</a>].</span>

      </p>

      <pre><code id="demofullanswer">(set-logic DTLIA)
(set-option :produce-models true)
(set-option :dump-models true)

; declaring module main 
  (declare-datatypes ((main 0)) (((main
    (a Int)
    (b Int)))))

  (define-fun line11col5!18 ((in main)) main
    (main
      ; assigning to a
      (a in)
      ; assigning to b
      1))

  (define-fun line10col5!14 ((in main)) main
    (main
      ; assigning to a
      0
      ; assigning to b
      (b in)))

  (define-fun main!init ((in main)) main
    (line11col5!18 (line10col5!14 in)))

  (define-fun line14col9!63 ((in main)) main
    (main
      ; assigning to a
      (a in)
      ; assigning to b
      (+
        (a in)
        (b in))))

  (define-fun line14col5!61 ((in main)) main
    (main
      ; assigning to a
      (b in)
      ; assigning to b
      (b in)))

  (define-fun main!next ((in main)) main
    (line14col9!63 (line14col5!61 in)))

  (synth-fun h ((x Int) (y Int)) Bool)

  (define-fun main!spec ((in main)) Bool
    (and
      (&lt;=
        (a in)
        (b in))
      (h
        (a in)
        (b in))))
; done declaring module main

(declare-var in!step!0 main)

(constraint (not (or
  (not (main!spec (main!init in!step!0)))
  (and
    (main!spec in!step!0)
    (not (main!spec (main!next in!step!0)))))))

(check-synth)</code></pre>

      <p>

        Defining the semantics of the core Uclid5 language by reducing modules
        to algebraic datatypes is not only clean, it also gives us
        first-class modules for free. Furthermore, separating the core language from the
        proof and procedure languages makes Uclid5 engineering more modular and simple.

      </p>

      <p>

        First-class modules do have some semantic subtleties. Namely,
        all fresh instances of a module are the term $i(k)$ for some arbitrary argument $k$.
        Similarly, taking a step of a module instance means to apply
        $n$ to it; updating the value of an instance's variable
        is the same as constructing a new instance that differs only by the
        value of that variable's selector.

      </p>
      <p>

        In other words, module instances are terms of sort $t$, and vice
        versa. For example, $i(k)$ and
        $n(i(k))$ are module instances. This means
        that two module instances are equal if they denote the same element of
        the domain of $t$: module instances use extensional equality on
        their state. Users should be aware of this when using modules to, e.g.,
        index into an array.

      </p>

      <h3 id="extensions">Core Extensions</h3>

      <p>

        <b>Module Interfaces. </b> Core modules, unlike the algebraic data-types
        that we have reduced them to, have an interface. This interface is
        defined by the keywords <code>var</code>, <code>input</code>, <code>output</code>, and
        <code>shared</code> that are used to declare module variables. Consider two
        modules, $m_1$ and $m_2$, where $m_1$ has an instance of $m_2$. In this
        situation, <code>var</code>s in $m_2$ are visible only to $m_2$; <code>input</code>s
        in $m_2$ are visible by both $m_1$ and $m_2$ but can only be written to
        by $m_1$; <code>output</code>s in $m_2$ are visible by both $m_1$ and $m_2$ but
        can only be written to by $m_2$; and <code>shared</code>s in $m_2$ are visible
        by both $m_1$ and $m_2$, and can be written to by both. Checking that the
        module interfaces are respected can be done at "compile-time" and
        erased for "execution-time," like generics in Java. Note that, because instance
        equality is extensional on state, checking equality on instances of $m_2$
        in $m_1$ requires that all variables in $m_2$ be visible to $m_1$.

      </p>

      <p>

        <b>Finite Linear Temporal Logic. </b>
        To support finite linear temporal logic (LTL) all we need to do is extend
        core language modules with a label sort $\tau$, a labeling function
        $f_{\text{label}}:t\tau$, and an LTL predicate
        $f_{\text{ltl}}:(\textbf{Seq} \tau)\textbf{Bool}$.
        Intuitively, $\tau$ is an alphabet, $f_{\text{label}}$ abstracts module
        states to characters of this alphabet, and $f_{\text{ltl}}$ checks patterns
        (e.g. regular expressions) on sequences of characters of this alphabet
        (traces). Note that we can automatically generate $f_{\text{label}}$ and
        $f_{\text{ltl}}$ from the existing Uclid5 LTL syntax by treating atomic
        predicates as labels.

      </p>

      <p>

        Later we will see how we can bounded model check LTL properties using these module extensions in the proof
        language.

      </p>

      <p>

        <b>Functions. </b>
        Core language modules can declare functions with the <code>define</code> keyword. These
        functions are immutable and are irrelevant to the state of a module, like
        $i$, $n$, and $s$. We keep track of
        <code>define</code> functions in a global context and they can be used freely by
        their module owner.

      </p>

      <p>

        <b>Inline Specifications. </b>
        Inline specifications in core language are lifted into $s$. Assertions
        are conjuncted to the existing specification, assumptions are negated and
        disjuncted (added as the antecedent of an implication). This is simple
        because the position of an inline specification in the core language is
        irrelevant (every line of code is "executed" in parallel).

      </p>

      <h2><a href="middle.html">Intermediate Representation</a></h2>
      <h2><a href="procedure.html">Procedure Langauge</a></h2>
      <h2><a href="proof.html">Proof Langauge</a></h2>

    </article>
  </main>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'],],
      },
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script type="text/javascript" src="js/uclidfc-opt.js"></script>
</body>

</html>